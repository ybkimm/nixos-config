diff --git a/cmd/gd/internal/builder/browser.go b/cmd/gd/internal/builder/browser.go
index 98fa3a48a..3c0e61733 100644
--- a/cmd/gd/internal/builder/browser.go
+++ b/cmd/gd/internal/builder/browser.go
@@ -14,6 +14,7 @@ import (
 
 	"graphics.gd/cmd/gd/internal/project"
 	"graphics.gd/cmd/gd/internal/tooling"
+	"graphics.gd/internal/tlsman"
 
 	"runtime.link/api/xray"
 )
@@ -60,7 +61,7 @@ func (browser Browser) Run(args ...string) error {
 	}
 	PORT := os.Getenv("PORT")
 	if PORT == "" {
-		PORT = "8080"
+		PORT = "8443"
 	}
 	if project.IncludesGo {
 		wasm_exec_path := filepath.Join(project.ReleasesDirectory, "js", "wasm", "wasm_exec.js")
@@ -80,10 +81,21 @@ func (browser Browser) Run(args ...string) error {
 			return xray.New(err)
 		}
 	}
-	fmt.Println("gd: serving wasm/js on http://localhost:" + PORT)
+	fmt.Println("gd: serving wasm/js on https://localhost:" + PORT)
 	browser.handler = http.FileServer(http.Dir(filepath.Join(project.ReleasesDirectory, "js", "wasm")))
-	http.Handle("/", browser)
-	return xray.New(http.ListenAndServe(":"+PORT, nil))
+
+	tlsConfig, err := tlsman.MakeTLSConfig()
+	if err != nil {
+		return xray.New(err)
+	}
+
+	svr := &http.Server{
+		Addr:      ":" + PORT,
+		Handler:   browser,
+		TLSConfig: tlsConfig,
+	}
+
+	return xray.New(svr.ListenAndServeTLS("", ""))
 }
 
 func (browser Browser) BuildMain(args ...string) error {
diff --git a/internal/tlsman/tlsman.go b/internal/tlsman/tlsman.go
new file mode 100644
index 000000000..4eaf8b994
--- /dev/null
+++ b/internal/tlsman/tlsman.go
@@ -0,0 +1,124 @@
+package tlsman
+
+import (
+	"crypto/rand"
+	"crypto/rsa"
+	"crypto/tls"
+	"crypto/x509"
+	"crypto/x509/pkix"
+	"encoding/pem"
+	"errors"
+	"log"
+	"math/big"
+	"net"
+	"os"
+	"path/filepath"
+	"time"
+)
+
+const (
+	TLSDir   = ".tls/"
+	CertFile = "cert.pem"
+	KeyFile  = "key.pem"
+)
+
+func generateCert() (tls.Certificate, error) {
+	priv, err := rsa.GenerateKey(rand.Reader, 2048)
+	if err != nil {
+		return tls.Certificate{}, err
+	}
+
+	template := x509.Certificate{
+		SerialNumber: big.NewInt(1),
+		Subject: pkix.Name{
+			Organization: []string{"Temp Proxy Server"},
+		},
+		NotBefore:             time.Now(),
+		NotAfter:              time.Now().Add(365 * 24 * time.Hour),
+		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
+		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
+		BasicConstraintsValid: true,
+		IPAddresses:           []net.IP{net.IPv4(127, 0, 0, 1)},
+		DNSNames:              []string{"localhost"},
+	}
+
+	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
+	if err != nil {
+		return tls.Certificate{}, err
+	}
+
+	cert := tls.Certificate{
+		Certificate: [][]byte{certDER},
+		PrivateKey:  priv,
+	}
+
+	return cert, nil
+}
+
+func loadCert() (tls.Certificate, error) {
+	certPath := filepath.Join(TLSDir, CertFile)
+	keyPath := filepath.Join(TLSDir, KeyFile)
+
+	return tls.LoadX509KeyPair(certPath, keyPath)
+}
+
+func saveCert(cert tls.Certificate) error {
+	err := os.MkdirAll(TLSDir, 0755)
+	if err != nil {
+		return err
+	}
+
+	certPath := filepath.Join(TLSDir, CertFile)
+	keyPath := filepath.Join(TLSDir, KeyFile)
+
+	certOut, err := os.Create(certPath)
+	if err != nil {
+		return err
+	}
+	defer certOut.Close()
+
+	err = pem.Encode(certOut, &pem.Block{
+		Type:  "CERTIFICATE",
+		Bytes: cert.Certificate[0],
+	})
+	if err != nil {
+		return err
+	}
+
+	privKey, ok := cert.PrivateKey.(*rsa.PrivateKey)
+	if !ok {
+		return errors.New("private key is not RSA")
+	}
+
+	keyOut, err := os.Create(keyPath)
+	if err != nil {
+		return err
+	}
+	defer keyOut.Close()
+
+	privKeyBytes := x509.MarshalPKCS1PrivateKey(privKey)
+	return pem.Encode(keyOut, &pem.Block{
+		Type:  "RSA PRIVATE KEY",
+		Bytes: privKeyBytes,
+	})
+}
+
+func MakeTLSConfig() (*tls.Config, error) {
+	cert, err := loadCert()
+	if errors.Is(err, os.ErrNotExist) {
+		cert, err = generateCert()
+		if err == nil {
+			err = saveCert(cert)
+			if err != nil {
+				log.Printf("Failed to save certificate: %v", err)
+			}
+		}
+	}
+	if err != nil {
+		return nil, err
+	}
+
+	return &tls.Config{
+		Certificates: []tls.Certificate{cert},
+	}, nil
+}
